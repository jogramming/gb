package mmu

import (
	"log"
	"os"
	"sync"
)

type MMU struct {
	InBios                  bool
	Bios                    []byte
	Rom                     []byte
	WorkingRam              []byte
	ExtRam                  []byte
	ZeroPageRam             []byte
	VideoRam                []byte
	OAM                     []byte // Graphics Object Attribute Memory
	IO                      []byte
	InterruptEnableRegister byte

	sync.Mutex
}

func (m *MMU) Initialize() {
	m.Bios = []byte{
		0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
		0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
		0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
		0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
		0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
		0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
		0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
		0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
		0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
		0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
		0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
		0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
		0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
		0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C,
		0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
		0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50,
	}
	m.Rom = []byte{}
	m.WorkingRam = make([]byte, 0x2000)
	m.VideoRam = make([]byte, 0x2000)
	m.ExtRam = make([]byte, 0x2000)
	m.OAM = make([]byte, 0xff)
	m.ZeroPageRam = make([]byte, 0x7f)
	m.InBios = true
	m.IO = make([]byte, 0x80)
}

func (m *MMU) SetPostBoot() {
	m.InBios = false

	m.IO[0x5] = 0x00
	m.IO[0x6] = 0x00
	m.IO[0x7] = 0x00
	m.IO[0x10] = 0x80
	m.IO[0x11] = 0xBF
	m.IO[0x12] = 0xF3
	m.IO[0x14] = 0xBF
	m.IO[0x16] = 0x3F
	m.IO[0x17] = 0x00
	m.IO[0x19] = 0xBF
	m.IO[0x1A] = 0x7F
	m.IO[0x1B] = 0xFF
	m.IO[0x1C] = 0x9F
	m.IO[0x1E] = 0xBF
	m.IO[0x20] = 0xFF
	m.IO[0x21] = 0x00
	m.IO[0x22] = 0x00
	m.IO[0x23] = 0xBF
	m.IO[0x24] = 0x77
	m.IO[0x25] = 0xF3
	m.IO[0x26] = 0xF1
	m.IO[0x40] = 0x91
	m.IO[0x42] = 0x00
	m.IO[0x43] = 0x00
	m.IO[0x45] = 0x00
	m.IO[0x47] = 0xFC
	m.IO[0x48] = 0xFF
	m.IO[0x49] = 0xFF
	m.IO[0x4A] = 0x00
	m.IO[0x4B] = 0x00
}

// Reads a byte from memory
func (m *MMU) ReadByte(addr uint16) byte {
	m.Lock()
	defer m.Unlock()
	switch {
	// Bios / rom0
	case addr < 0x1000:
		if m.InBios && addr < 0x00ff {
			// Bios
			return m.Bios[addr]
		}
		if int(addr) > len(m.Rom) {
			log.Println("Tried accessing out of bounds! In bios?", m.InBios)
			os.Exit(1)
			return 0
		}
		return m.Rom[addr]
	// Rom bank 0
	case addr >= 0x1000 && addr < 0x4000:
		return m.Rom[addr]
	//Switchable rom bank
	case addr >= 0x4000 && addr < 0x8000:
		return m.Rom[addr]
	// Graphics video ram (8k)
	case addr >= 0x8000 && addr < 0xa000:
		return m.VideoRam[addr&0x1fff]
	// Ext Ram (8k)
	case addr >= 0xa000 && addr < 0xc000:
		return m.ExtRam[addr&0x1fff]
	// Working ram (8k)
	case addr >= 0xc000 && addr < 0xe000:
		return m.WorkingRam[addr&0x1fff]
	// Wroking ram shadow
	case addr >= 0xe000 && addr < 0xfdff:
		return m.WorkingRam[addr&0x1fff]
	// Graphics OAM
	case addr >= 0xfe00 && addr < 0xfea0:
		return m.OAM[addr&0xff]
	// IO
	case addr >= 0xff00 && addr < 0xff4c:
		return m.IO[addr-0xff00]
	// Zero Page Ram
	case addr >= 0xff80 && addr < 0xffff:
		return m.ZeroPageRam[addr&0x7f]
	case addr == 0xffff:
		return m.InterruptEnableRegister
	}

	return 0
}

// Reads 2 bytes from memory
func (m *MMU) ReadWord(addr uint16) uint16 {
	val1 := m.ReadByte(addr)
	val2 := m.ReadByte(addr + 1)

	return uint16(val2)<<8 | uint16(val1)
}

func (m *MMU) WriteByte(addr uint16, data byte) {
	m.Lock()
	defer m.Unlock()
	switch {
	// Video ram (8k)
	case addr >= 0x8000 && addr < 0xa000:
		m.VideoRam[addr&0x1fff] = data
	// Ext Ram (8k)
	case addr >= 0xa000 && addr < 0xc000:
		m.ExtRam[addr&0x1fff] = data
	// Working ram (8k)
	case addr >= 0xc000 && addr < 0xe000:
		m.WorkingRam[addr&0x1fff] = data
	// Wroking ram shadow
	case addr >= 0xe000 && addr < 0xfdff:
		m.WorkingRam[addr&0x1fff] = data
	// Graphics OAM
	case addr >= 0xfe00 && addr < 0xfea0:
		m.OAM[addr&0xff] = data
	// IO
	case addr >= 0xff00 && addr < 0xff80:
		log.Printf("Writing to 0x%X or 0x%X\n", addr, addr-0xff00)
		m.IO[addr-0xff00] = data
	// Zero Page Ram
	case addr >= 0xff80 && addr < 0xffff:
		m.ZeroPageRam[addr&0x7f] = data
	case addr == 0xffff:
		m.InterruptEnableRegister = data
	}
}

func (m *MMU) WriteWord(addr, data uint16) {
	m.WriteByte(addr, byte(data&255))
	m.WriteByte(addr+1, byte(data>>8))
}
